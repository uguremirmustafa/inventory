// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: item.sql

package db

import (
	"context"
	"database/sql"
)

const insertItemInfo = `-- name: InsertItemInfo :one
INSERT INTO item_info (
    item_id,
    purchase_date,
    purchase_location,
    price,
    expiration_date,
    last_used,
    location_id
) VALUES (
    $1, -- item_id
	$2, -- purchase_date
	$3, -- purchase_location
	$4, -- price
	$5, -- expiration_date
	$6, -- last_used
	$7  -- location_id
) RETURNING id
`

type InsertItemInfoParams struct {
	ItemID           int64          `db:"item_id" json:"item_id"`
	PurchaseDate     sql.NullTime   `db:"purchase_date" json:"purchase_date"`
	PurchaseLocation sql.NullString `db:"purchase_location" json:"purchase_location"`
	Price            sql.NullInt64  `db:"price" json:"price"`
	ExpirationDate   sql.NullTime   `db:"expiration_date" json:"expiration_date"`
	LastUsed         sql.NullTime   `db:"last_used" json:"last_used"`
	LocationID       sql.NullInt64  `db:"location_id" json:"location_id"`
}

func (q *Queries) InsertItemInfo(ctx context.Context, arg InsertItemInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertItemInfo,
		arg.ItemID,
		arg.PurchaseDate,
		arg.PurchaseLocation,
		arg.Price,
		arg.ExpirationDate,
		arg.LastUsed,
		arg.LocationID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertUserItem = `-- name: InsertUserItem :one
INSERT INTO item (
    name,
    description,
    user_id,
    item_type_id,
    manufacturer_id,
	group_id
) VALUES (
    $1, -- name
	$2, -- description
	$3, -- user_id
	$4, -- item_type_id
	$5,  -- manufacturer_id
	$6
) RETURNING id
`

type InsertUserItemParams struct {
	Name           string         `db:"name" json:"name"`
	Description    sql.NullString `db:"description" json:"description"`
	UserID         int64          `db:"user_id" json:"user_id"`
	ItemTypeID     int64          `db:"item_type_id" json:"item_type_id"`
	ManufacturerID sql.NullInt64  `db:"manufacturer_id" json:"manufacturer_id"`
	GroupID        int64          `db:"group_id" json:"group_id"`
}

func (q *Queries) InsertUserItem(ctx context.Context, arg InsertUserItemParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertUserItem,
		arg.Name,
		arg.Description,
		arg.UserID,
		arg.ItemTypeID,
		arg.ManufacturerID,
		arg.GroupID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listItemImages = `-- name: ListItemImages :many
SELECT 
    ii.item_id,
    ii.image_url
FROM 
    item_image ii
WHERE 
    ii.item_id = $1
    AND ii.deleted_at IS NULL
ORDER BY 
    ii.created_at DESC
LIMIT $2
`

type ListItemImagesParams struct {
	ItemID int64 `db:"item_id" json:"item_id"`
	Limit  int32 `db:"limit" json:"limit"`
}

type ListItemImagesRow struct {
	ItemID   int64  `db:"item_id" json:"item_id"`
	ImageUrl string `db:"image_url" json:"image_url"`
}

func (q *Queries) ListItemImages(ctx context.Context, arg ListItemImagesParams) ([]ListItemImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, listItemImages, arg.ItemID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemImagesRow
	for rows.Next() {
		var i ListItemImagesRow
		if err := rows.Scan(&i.ItemID, &i.ImageUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItems = `-- name: ListItems :many
SELECT 
    i.id AS item_id,
    i.name AS item_name,
    i.description AS item_description,
    i.created_at AS created_at,
    i.updated_at AS updated_at
FROM 
    item i
WHERE 
    i.deleted_at IS NULL 
    AND i.group_id = $1
ORDER BY 
    i.updated_at DESC
`

type ListItemsRow struct {
	ItemID          int64          `db:"item_id" json:"item_id"`
	ItemName        string         `db:"item_name" json:"item_name"`
	ItemDescription sql.NullString `db:"item_description" json:"item_description"`
	CreatedAt       sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt       sql.NullTime   `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListItems(ctx context.Context, groupID int64) ([]ListItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listItems, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsRow
	for rows.Next() {
		var i ListItemsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.ItemDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserItems = `-- name: ListUserItems :many
SELECT 
    i.id AS item_id,
	i.name AS item_name,
	i.description AS item_description,
	u.name AS user_name,
	u.email AS user_email,
	it.id AS item_type_id,
	it.name AS item_type_name,
	man.id AS manufacturer_id,
	man.name AS manufacturer_name,
	ii.id AS item_info_id,
	ii.purchase_date AS purchase_date,
	ii.purchase_location AS purchase_location,
	ii.price AS price,
	ii.expiration_date AS expiration_date,
	ii.last_used AS last_used,
	loc.id AS location_id,
	loc.name AS location_name,
	loc.description AS location_description,
	loc.image_url AS location_img
FROM item i
LEFT JOIN users u ON i.user_id = u.id AND u.deleted_at is null
LEFT JOIN item_type it ON i.item_type_id = it.id AND it.deleted_at is null
LEFT JOIN manufacturer man ON i.manufacturer_id = man.id AND man.deleted_at is null
LEFT JOIN item_info ii ON ii.item_id = i.id AND ii.deleted_at is null
LEFT JOIN location loc ON ii.location_id = loc.id AND loc.deleted_at is null
WHERE u.id = $1 AND i.deleted_at is null
`

type ListUserItemsRow struct {
	ItemID              int64          `db:"item_id" json:"item_id"`
	ItemName            string         `db:"item_name" json:"item_name"`
	ItemDescription     sql.NullString `db:"item_description" json:"item_description"`
	UserName            sql.NullString `db:"user_name" json:"user_name"`
	UserEmail           sql.NullString `db:"user_email" json:"user_email"`
	ItemTypeID          sql.NullInt64  `db:"item_type_id" json:"item_type_id"`
	ItemTypeName        sql.NullString `db:"item_type_name" json:"item_type_name"`
	ManufacturerID      sql.NullInt64  `db:"manufacturer_id" json:"manufacturer_id"`
	ManufacturerName    sql.NullString `db:"manufacturer_name" json:"manufacturer_name"`
	ItemInfoID          sql.NullInt64  `db:"item_info_id" json:"item_info_id"`
	PurchaseDate        sql.NullTime   `db:"purchase_date" json:"purchase_date"`
	PurchaseLocation    sql.NullString `db:"purchase_location" json:"purchase_location"`
	Price               sql.NullInt64  `db:"price" json:"price"`
	ExpirationDate      sql.NullTime   `db:"expiration_date" json:"expiration_date"`
	LastUsed            sql.NullTime   `db:"last_used" json:"last_used"`
	LocationID          sql.NullInt64  `db:"location_id" json:"location_id"`
	LocationName        sql.NullString `db:"location_name" json:"location_name"`
	LocationDescription sql.NullString `db:"location_description" json:"location_description"`
	LocationImg         sql.NullString `db:"location_img" json:"location_img"`
}

func (q *Queries) ListUserItems(ctx context.Context, id int64) ([]ListUserItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserItems, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserItemsRow
	for rows.Next() {
		var i ListUserItemsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.ItemDescription,
			&i.UserName,
			&i.UserEmail,
			&i.ItemTypeID,
			&i.ItemTypeName,
			&i.ManufacturerID,
			&i.ManufacturerName,
			&i.ItemInfoID,
			&i.PurchaseDate,
			&i.PurchaseLocation,
			&i.Price,
			&i.ExpirationDate,
			&i.LastUsed,
			&i.LocationID,
			&i.LocationName,
			&i.LocationDescription,
			&i.LocationImg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
